// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace vector_tile {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class VectorTile {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    #endregion
    #region Extensions
    internal static readonly object Descriptor;
    static VectorTile() {
      Descriptor = null;
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Tile : pb::ExtendableMessageLite<Tile, Tile.Builder> {
    private Tile() { }
    private static readonly Tile defaultInstance = new Tile().MakeReadOnly();
    private static readonly string[] _tileFieldNames = new string[] { "layers" };
    private static readonly uint[] _tileFieldTags = new uint[] { 26 };
    public static Tile DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Tile DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Tile ThisMessage {
      get { return this; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum GeomType {
        UNKNOWN = 0,
        POINT = 1,
        LINESTRING = 2,
        POLYGON = 3,
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Value : pb::ExtendableMessageLite<Value, Value.Builder> {
        private Value() { }
        private static readonly Value defaultInstance = new Value().MakeReadOnly();
        private static readonly string[] _valueFieldNames = new string[] { "bool_value", "double_value", "float_value", "int_value", "sint_value", "string_value", "uint_value" };
        private static readonly uint[] _valueFieldTags = new uint[] { 56, 25, 21, 32, 48, 10, 40 };
        public static Value DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Value DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Value ThisMessage {
          get { return this; }
        }
        
        public const int StringValueFieldNumber = 1;
        private bool hasStringValue;
        private string stringValue_ = "";
        public bool HasStringValue {
          get { return hasStringValue; }
        }
        public string StringValue {
          get { return stringValue_; }
        }
        
        public const int FloatValueFieldNumber = 2;
        private bool hasFloatValue;
        private float floatValue_;
        public bool HasFloatValue {
          get { return hasFloatValue; }
        }
        public float FloatValue {
          get { return floatValue_; }
        }
        
        public const int DoubleValueFieldNumber = 3;
        private bool hasDoubleValue;
        private double doubleValue_;
        public bool HasDoubleValue {
          get { return hasDoubleValue; }
        }
        public double DoubleValue {
          get { return doubleValue_; }
        }
        
        public const int IntValueFieldNumber = 4;
        private bool hasIntValue;
        private long intValue_;
        public bool HasIntValue {
          get { return hasIntValue; }
        }
        public long IntValue {
          get { return intValue_; }
        }
        
        public const int UintValueFieldNumber = 5;
        private bool hasUintValue;
        private ulong uintValue_;
        public bool HasUintValue {
          get { return hasUintValue; }
        }
        [global::System.CLSCompliant(false)]
        public ulong UintValue {
          get { return uintValue_; }
        }
        
        public const int SintValueFieldNumber = 6;
        private bool hasSintValue;
        private long sintValue_;
        public bool HasSintValue {
          get { return hasSintValue; }
        }
        public long SintValue {
          get { return sintValue_; }
        }
        
        public const int BoolValueFieldNumber = 7;
        private bool hasBoolValue;
        private bool boolValue_;
        public bool HasBoolValue {
          get { return hasBoolValue; }
        }
        public bool BoolValue {
          get { return boolValue_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!ExtensionsAreInitialized) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _valueFieldNames;
          pb::ExtendableMessageLite<Value, Value.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
          if (hasStringValue) {
            output.WriteString(1, field_names[5], StringValue);
          }
          if (hasFloatValue) {
            output.WriteFloat(2, field_names[2], FloatValue);
          }
          if (hasDoubleValue) {
            output.WriteDouble(3, field_names[1], DoubleValue);
          }
          if (hasIntValue) {
            output.WriteInt64(4, field_names[3], IntValue);
          }
          if (hasUintValue) {
            output.WriteUInt64(5, field_names[6], UintValue);
          }
          if (hasSintValue) {
            output.WriteSInt64(6, field_names[4], SintValue);
          }
          if (hasBoolValue) {
            output.WriteBool(7, field_names[0], BoolValue);
          }
          extensionWriter.WriteUntil(536870912, output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasStringValue) {
            size += pb::CodedOutputStream.ComputeStringSize(1, StringValue);
          }
          if (hasFloatValue) {
            size += pb::CodedOutputStream.ComputeFloatSize(2, FloatValue);
          }
          if (hasDoubleValue) {
            size += pb::CodedOutputStream.ComputeDoubleSize(3, DoubleValue);
          }
          if (hasIntValue) {
            size += pb::CodedOutputStream.ComputeInt64Size(4, IntValue);
          }
          if (hasUintValue) {
            size += pb::CodedOutputStream.ComputeUInt64Size(5, UintValue);
          }
          if (hasSintValue) {
            size += pb::CodedOutputStream.ComputeSInt64Size(6, SintValue);
          }
          if (hasBoolValue) {
            size += pb::CodedOutputStream.ComputeBoolSize(7, BoolValue);
          }
          size += ExtensionsSerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasStringValue) hash ^= stringValue_.GetHashCode();
          if (hasFloatValue) hash ^= floatValue_.GetHashCode();
          if (hasDoubleValue) hash ^= doubleValue_.GetHashCode();
          if (hasIntValue) hash ^= intValue_.GetHashCode();
          if (hasUintValue) hash ^= uintValue_.GetHashCode();
          if (hasSintValue) hash ^= sintValue_.GetHashCode();
          if (hasBoolValue) hash ^= boolValue_.GetHashCode();
          hash ^= base.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Value other = obj as Value;
          if (other == null) return false;
          if (hasStringValue != other.hasStringValue || (hasStringValue && !stringValue_.Equals(other.stringValue_))) return false;
          if (hasFloatValue != other.hasFloatValue || (hasFloatValue && !floatValue_.Equals(other.floatValue_))) return false;
          if (hasDoubleValue != other.hasDoubleValue || (hasDoubleValue && !doubleValue_.Equals(other.doubleValue_))) return false;
          if (hasIntValue != other.hasIntValue || (hasIntValue && !intValue_.Equals(other.intValue_))) return false;
          if (hasUintValue != other.hasUintValue || (hasUintValue && !uintValue_.Equals(other.uintValue_))) return false;
          if (hasSintValue != other.hasSintValue || (hasSintValue && !sintValue_.Equals(other.sintValue_))) return false;
          if (hasBoolValue != other.hasBoolValue || (hasBoolValue && !boolValue_.Equals(other.boolValue_))) return false;
          if (!base.Equals(other)) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("string_value", hasStringValue, stringValue_, writer);
          PrintField("float_value", hasFloatValue, floatValue_, writer);
          PrintField("double_value", hasDoubleValue, doubleValue_, writer);
          PrintField("int_value", hasIntValue, intValue_, writer);
          PrintField("uint_value", hasUintValue, uintValue_, writer);
          PrintField("sint_value", hasSintValue, sintValue_, writer);
          PrintField("bool_value", hasBoolValue, boolValue_, writer);
          base.PrintTo(writer);
        }
        #endregion
        
        public static Value ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Value ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Value ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Value ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Value ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Value ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Value ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Value ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Value ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Value ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Value MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Value prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilderLite<Value, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Value cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Value result;
          
          private Value PrepareBuilder() {
            if (resultIsReadOnly) {
              Value original = result;
              result = new Value();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Value MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Value DefaultInstanceForType {
            get { return global::vector_tile.Tile.Types.Value.DefaultInstance; }
          }
          
          public override Value BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Value) {
              return MergeFrom((Value) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Value other) {
            if (other == global::vector_tile.Tile.Types.Value.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasStringValue) {
              StringValue = other.StringValue;
            }
            if (other.HasFloatValue) {
              FloatValue = other.FloatValue;
            }
            if (other.HasDoubleValue) {
              DoubleValue = other.DoubleValue;
            }
            if (other.HasIntValue) {
              IntValue = other.IntValue;
            }
            if (other.HasUintValue) {
              UintValue = other.UintValue;
            }
            if (other.HasSintValue) {
              SintValue = other.SintValue;
            }
            if (other.HasBoolValue) {
              BoolValue = other.BoolValue;
            }
              this.MergeExtensionFields(other);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_valueFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _valueFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasStringValue = input.ReadString(ref result.stringValue_);
                  break;
                }
                case 21: {
                  result.hasFloatValue = input.ReadFloat(ref result.floatValue_);
                  break;
                }
                case 25: {
                  result.hasDoubleValue = input.ReadDouble(ref result.doubleValue_);
                  break;
                }
                case 32: {
                  result.hasIntValue = input.ReadInt64(ref result.intValue_);
                  break;
                }
                case 40: {
                  result.hasUintValue = input.ReadUInt64(ref result.uintValue_);
                  break;
                }
                case 48: {
                  result.hasSintValue = input.ReadSInt64(ref result.sintValue_);
                  break;
                }
                case 56: {
                  result.hasBoolValue = input.ReadBool(ref result.boolValue_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasStringValue {
            get { return result.hasStringValue; }
          }
          public string StringValue {
            get { return result.StringValue; }
            set { SetStringValue(value); }
          }
          public Builder SetStringValue(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasStringValue = true;
            result.stringValue_ = value;
            return this;
          }
          public Builder ClearStringValue() {
            PrepareBuilder();
            result.hasStringValue = false;
            result.stringValue_ = "";
            return this;
          }
          
          public bool HasFloatValue {
            get { return result.hasFloatValue; }
          }
          public float FloatValue {
            get { return result.FloatValue; }
            set { SetFloatValue(value); }
          }
          public Builder SetFloatValue(float value) {
            PrepareBuilder();
            result.hasFloatValue = true;
            result.floatValue_ = value;
            return this;
          }
          public Builder ClearFloatValue() {
            PrepareBuilder();
            result.hasFloatValue = false;
            result.floatValue_ = 0F;
            return this;
          }
          
          public bool HasDoubleValue {
            get { return result.hasDoubleValue; }
          }
          public double DoubleValue {
            get { return result.DoubleValue; }
            set { SetDoubleValue(value); }
          }
          public Builder SetDoubleValue(double value) {
            PrepareBuilder();
            result.hasDoubleValue = true;
            result.doubleValue_ = value;
            return this;
          }
          public Builder ClearDoubleValue() {
            PrepareBuilder();
            result.hasDoubleValue = false;
            result.doubleValue_ = 0D;
            return this;
          }
          
          public bool HasIntValue {
            get { return result.hasIntValue; }
          }
          public long IntValue {
            get { return result.IntValue; }
            set { SetIntValue(value); }
          }
          public Builder SetIntValue(long value) {
            PrepareBuilder();
            result.hasIntValue = true;
            result.intValue_ = value;
            return this;
          }
          public Builder ClearIntValue() {
            PrepareBuilder();
            result.hasIntValue = false;
            result.intValue_ = 0L;
            return this;
          }
          
          public bool HasUintValue {
            get { return result.hasUintValue; }
          }
          [global::System.CLSCompliant(false)]
          public ulong UintValue {
            get { return result.UintValue; }
            set { SetUintValue(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetUintValue(ulong value) {
            PrepareBuilder();
            result.hasUintValue = true;
            result.uintValue_ = value;
            return this;
          }
          public Builder ClearUintValue() {
            PrepareBuilder();
            result.hasUintValue = false;
            result.uintValue_ = 0UL;
            return this;
          }
          
          public bool HasSintValue {
            get { return result.hasSintValue; }
          }
          public long SintValue {
            get { return result.SintValue; }
            set { SetSintValue(value); }
          }
          public Builder SetSintValue(long value) {
            PrepareBuilder();
            result.hasSintValue = true;
            result.sintValue_ = value;
            return this;
          }
          public Builder ClearSintValue() {
            PrepareBuilder();
            result.hasSintValue = false;
            result.sintValue_ = 0;
            return this;
          }
          
          public bool HasBoolValue {
            get { return result.hasBoolValue; }
          }
          public bool BoolValue {
            get { return result.BoolValue; }
            set { SetBoolValue(value); }
          }
          public Builder SetBoolValue(bool value) {
            PrepareBuilder();
            result.hasBoolValue = true;
            result.boolValue_ = value;
            return this;
          }
          public Builder ClearBoolValue() {
            PrepareBuilder();
            result.hasBoolValue = false;
            result.boolValue_ = false;
            return this;
          }
        }
        static Value() {
          object.ReferenceEquals(global::vector_tile.VectorTile.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Feature : pb::GeneratedMessageLite<Feature, Feature.Builder> {
        private Feature() { }
        private static readonly Feature defaultInstance = new Feature().MakeReadOnly();
        private static readonly string[] _featureFieldNames = new string[] { "geometry", "id", "tags", "type" };
        private static readonly uint[] _featureFieldTags = new uint[] { 34, 8, 18, 24 };
        public static Feature DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Feature DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Feature ThisMessage {
          get { return this; }
        }
        
        public const int IdFieldNumber = 1;
        private bool hasId;
        private ulong id_;
        public bool HasId {
          get { return hasId; }
        }
        [global::System.CLSCompliant(false)]
        public ulong Id {
          get { return id_; }
        }
        
        public const int TagsFieldNumber = 2;
        private int tagsMemoizedSerializedSize;
        private pbc::PopsicleList<uint> tags_ = new pbc::PopsicleList<uint>();
        [global::System.CLSCompliant(false)]
        public scg::IList<uint> TagsList {
          get { return pbc::Lists.AsReadOnly(tags_); }
        }
        public int TagsCount {
          get { return tags_.Count; }
        }
        [global::System.CLSCompliant(false)]
        public uint GetTags(int index) {
          return tags_[index];
        }
        
        public const int TypeFieldNumber = 3;
        private bool hasType;
        private global::vector_tile.Tile.Types.GeomType type_ = global::vector_tile.Tile.Types.GeomType.UNKNOWN;
        public bool HasType {
          get { return hasType; }
        }
        public global::vector_tile.Tile.Types.GeomType Type {
          get { return type_; }
        }
        
        public const int GeometryFieldNumber = 4;
        private int geometryMemoizedSerializedSize;
        private pbc::PopsicleList<uint> geometry_ = new pbc::PopsicleList<uint>();
        [global::System.CLSCompliant(false)]
        public scg::IList<uint> GeometryList {
          get { return pbc::Lists.AsReadOnly(geometry_); }
        }
        public int GeometryCount {
          get { return geometry_.Count; }
        }
        [global::System.CLSCompliant(false)]
        public uint GetGeometry(int index) {
          return geometry_[index];
        }
        
        public override bool IsInitialized {
          get {
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _featureFieldNames;
          if (hasId) {
            output.WriteUInt64(1, field_names[1], Id);
          }
          if (tags_.Count > 0) {
            output.WritePackedUInt32Array(2, field_names[2], tagsMemoizedSerializedSize, tags_);
          }
          if (hasType) {
            output.WriteEnum(3, field_names[3], (int) Type, Type);
          }
          if (geometry_.Count > 0) {
            output.WritePackedUInt32Array(4, field_names[0], geometryMemoizedSerializedSize, geometry_);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasId) {
            size += pb::CodedOutputStream.ComputeUInt64Size(1, Id);
          }
          {
            int dataSize = 0;
            foreach (uint element in TagsList) {
              dataSize += pb::CodedOutputStream.ComputeUInt32SizeNoTag(element);
            }
            size += dataSize;
            if (tags_.Count != 0) {
              size += 1 + pb::CodedOutputStream.ComputeInt32SizeNoTag(dataSize);
            }
            tagsMemoizedSerializedSize = dataSize;
          }
          if (hasType) {
            size += pb::CodedOutputStream.ComputeEnumSize(3, (int) Type);
          }
          {
            int dataSize = 0;
            foreach (uint element in GeometryList) {
              dataSize += pb::CodedOutputStream.ComputeUInt32SizeNoTag(element);
            }
            size += dataSize;
            if (geometry_.Count != 0) {
              size += 1 + pb::CodedOutputStream.ComputeInt32SizeNoTag(dataSize);
            }
            geometryMemoizedSerializedSize = dataSize;
          }
          memoizedSerializedSize = size;
          return size;
        }
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasId) hash ^= id_.GetHashCode();
          foreach(uint i in tags_)
            hash ^= i.GetHashCode();
          if (hasType) hash ^= type_.GetHashCode();
          foreach(uint i in geometry_)
            hash ^= i.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Feature other = obj as Feature;
          if (other == null) return false;
          if (hasId != other.hasId || (hasId && !id_.Equals(other.id_))) return false;
          if(tags_.Count != other.tags_.Count) return false;
          for(int ix=0; ix < tags_.Count; ix++)
            if(!tags_[ix].Equals(other.tags_[ix])) return false;
          if (hasType != other.hasType || (hasType && !type_.Equals(other.type_))) return false;
          if(geometry_.Count != other.geometry_.Count) return false;
          for(int ix=0; ix < geometry_.Count; ix++)
            if(!geometry_[ix].Equals(other.geometry_[ix])) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("id", hasId, id_, writer);
          PrintField("tags", tags_, writer);
          PrintField("type", hasType, type_, writer);
          PrintField("geometry", geometry_, writer);
        }
        #endregion
        
        public static Feature ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Feature ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Feature ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Feature ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Feature ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Feature ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Feature ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Feature ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Feature ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Feature ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Feature MakeReadOnly() {
          tags_.MakeReadOnly();
          geometry_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Feature prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<Feature, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Feature cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Feature result;
          
          private Feature PrepareBuilder() {
            if (resultIsReadOnly) {
              Feature original = result;
              result = new Feature();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Feature MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Feature DefaultInstanceForType {
            get { return global::vector_tile.Tile.Types.Feature.DefaultInstance; }
          }
          
          public override Feature BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Feature) {
              return MergeFrom((Feature) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Feature other) {
            if (other == global::vector_tile.Tile.Types.Feature.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasId) {
              Id = other.Id;
            }
            if (other.tags_.Count != 0) {
              result.tags_.Add(other.tags_);
            }
            if (other.HasType) {
              Type = other.Type;
            }
            if (other.geometry_.Count != 0) {
              result.geometry_.Add(other.geometry_);
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_featureFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _featureFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 8: {
                  result.hasId = input.ReadUInt64(ref result.id_);
                  break;
                }
                case 18:
                case 16: {
                  input.ReadUInt32Array(tag, field_name, result.tags_);
                  break;
                }
                case 24: {
                  object unknown;
                  if(input.ReadEnum(ref result.type_, out unknown)) {
                    result.hasType = true;
                  } else if(unknown is int) {
                  }
                  break;
                }
                case 34:
                case 32: {
                  input.ReadUInt32Array(tag, field_name, result.geometry_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasId {
            get { return result.hasId; }
          }
          [global::System.CLSCompliant(false)]
          public ulong Id {
            get { return result.Id; }
            set { SetId(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetId(ulong value) {
            PrepareBuilder();
            result.hasId = true;
            result.id_ = value;
            return this;
          }
          public Builder ClearId() {
            PrepareBuilder();
            result.hasId = false;
            result.id_ = 0UL;
            return this;
          }
          
          [global::System.CLSCompliant(false)]
          public pbc::IPopsicleList<uint> TagsList {
            get { return PrepareBuilder().tags_; }
          }
          public int TagsCount {
            get { return result.TagsCount; }
          }
          [global::System.CLSCompliant(false)]
          public uint GetTags(int index) {
            return result.GetTags(index);
          }
          [global::System.CLSCompliant(false)]
          public Builder SetTags(int index, uint value) {
            PrepareBuilder();
            result.tags_[index] = value;
            return this;
          }
          [global::System.CLSCompliant(false)]
          public Builder AddTags(uint value) {
            PrepareBuilder();
            result.tags_.Add(value);
            return this;
          }
          [global::System.CLSCompliant(false)]
          public Builder AddRangeTags(scg::IEnumerable<uint> values) {
            PrepareBuilder();
            result.tags_.Add(values);
            return this;
          }
          public Builder ClearTags() {
            PrepareBuilder();
            result.tags_.Clear();
            return this;
          }
          
          public bool HasType {
           get { return result.hasType; }
          }
          public global::vector_tile.Tile.Types.GeomType Type {
            get { return result.Type; }
            set { SetType(value); }
          }
          public Builder SetType(global::vector_tile.Tile.Types.GeomType value) {
            PrepareBuilder();
            result.hasType = true;
            result.type_ = value;
            return this;
          }
          public Builder ClearType() {
            PrepareBuilder();
            result.hasType = false;
            result.type_ = global::vector_tile.Tile.Types.GeomType.UNKNOWN;
            return this;
          }
          
          [global::System.CLSCompliant(false)]
          public pbc::IPopsicleList<uint> GeometryList {
            get { return PrepareBuilder().geometry_; }
          }
          public int GeometryCount {
            get { return result.GeometryCount; }
          }
          [global::System.CLSCompliant(false)]
          public uint GetGeometry(int index) {
            return result.GetGeometry(index);
          }
          [global::System.CLSCompliant(false)]
          public Builder SetGeometry(int index, uint value) {
            PrepareBuilder();
            result.geometry_[index] = value;
            return this;
          }
          [global::System.CLSCompliant(false)]
          public Builder AddGeometry(uint value) {
            PrepareBuilder();
            result.geometry_.Add(value);
            return this;
          }
          [global::System.CLSCompliant(false)]
          public Builder AddRangeGeometry(scg::IEnumerable<uint> values) {
            PrepareBuilder();
            result.geometry_.Add(values);
            return this;
          }
          public Builder ClearGeometry() {
            PrepareBuilder();
            result.geometry_.Clear();
            return this;
          }
        }
        static Feature() {
          object.ReferenceEquals(global::vector_tile.VectorTile.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Layer : pb::ExtendableMessageLite<Layer, Layer.Builder> {
        private Layer() { }
        private static readonly Layer defaultInstance = new Layer().MakeReadOnly();
        private static readonly string[] _layerFieldNames = new string[] { "extent", "features", "keys", "name", "values", "version" };
        private static readonly uint[] _layerFieldTags = new uint[] { 40, 18, 26, 10, 34, 120 };
        public static Layer DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Layer DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Layer ThisMessage {
          get { return this; }
        }
        
        public const int VersionFieldNumber = 15;
        private bool hasVersion;
        private uint version_ = 1;
        public bool HasVersion {
          get { return hasVersion; }
        }
        [global::System.CLSCompliant(false)]
        public uint Version {
          get { return version_; }
        }
        
        public const int NameFieldNumber = 1;
        private bool hasName;
        private string name_ = "";
        public bool HasName {
          get { return hasName; }
        }
        public string Name {
          get { return name_; }
        }
        
        public const int FeaturesFieldNumber = 2;
        private pbc::PopsicleList<global::vector_tile.Tile.Types.Feature> features_ = new pbc::PopsicleList<global::vector_tile.Tile.Types.Feature>();
        public scg::IList<global::vector_tile.Tile.Types.Feature> FeaturesList {
          get { return features_; }
        }
        public int FeaturesCount {
          get { return features_.Count; }
        }
        public global::vector_tile.Tile.Types.Feature GetFeatures(int index) {
          return features_[index];
        }
        
        public const int KeysFieldNumber = 3;
        private pbc::PopsicleList<string> keys_ = new pbc::PopsicleList<string>();
        public scg::IList<string> KeysList {
          get { return pbc::Lists.AsReadOnly(keys_); }
        }
        public int KeysCount {
          get { return keys_.Count; }
        }
        public string GetKeys(int index) {
          return keys_[index];
        }
        
        public const int ValuesFieldNumber = 4;
        private pbc::PopsicleList<global::vector_tile.Tile.Types.Value> values_ = new pbc::PopsicleList<global::vector_tile.Tile.Types.Value>();
        public scg::IList<global::vector_tile.Tile.Types.Value> ValuesList {
          get { return values_; }
        }
        public int ValuesCount {
          get { return values_.Count; }
        }
        public global::vector_tile.Tile.Types.Value GetValues(int index) {
          return values_[index];
        }
        
        public const int ExtentFieldNumber = 5;
        private bool hasExtent;
        private uint extent_ = 4096;
        public bool HasExtent {
          get { return hasExtent; }
        }
        [global::System.CLSCompliant(false)]
        public uint Extent {
          get { return extent_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasVersion) return false;
            if (!hasName) return false;
            if (!ExtensionsAreInitialized) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _layerFieldNames;
          pb::ExtendableMessageLite<Layer, Layer.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
          if (hasName) {
            output.WriteString(1, field_names[3], Name);
          }
          if (features_.Count > 0) {
            output.WriteMessageArray(2, field_names[1], features_);
          }
          if (keys_.Count > 0) {
            output.WriteStringArray(3, field_names[2], keys_);
          }
          if (values_.Count > 0) {
            output.WriteMessageArray(4, field_names[4], values_);
          }
          if (hasExtent) {
            output.WriteUInt32(5, field_names[0], Extent);
          }
          if (hasVersion) {
            output.WriteUInt32(15, field_names[5], Version);
          }
          extensionWriter.WriteUntil(536870912, output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasVersion) {
            size += pb::CodedOutputStream.ComputeUInt32Size(15, Version);
          }
          if (hasName) {
            size += pb::CodedOutputStream.ComputeStringSize(1, Name);
          }
          foreach (global::vector_tile.Tile.Types.Feature element in FeaturesList) {
            size += pb::CodedOutputStream.ComputeMessageSize(2, element);
          }
          {
            int dataSize = 0;
            foreach (string element in KeysList) {
              dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
            }
            size += dataSize;
            size += 1 * keys_.Count;
          }
          foreach (global::vector_tile.Tile.Types.Value element in ValuesList) {
            size += pb::CodedOutputStream.ComputeMessageSize(4, element);
          }
          if (hasExtent) {
            size += pb::CodedOutputStream.ComputeUInt32Size(5, Extent);
          }
          size += ExtensionsSerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasVersion) hash ^= version_.GetHashCode();
          if (hasName) hash ^= name_.GetHashCode();
          foreach(global::vector_tile.Tile.Types.Feature i in features_)
            hash ^= i.GetHashCode();
          foreach(string i in keys_)
            hash ^= i.GetHashCode();
          foreach(global::vector_tile.Tile.Types.Value i in values_)
            hash ^= i.GetHashCode();
          if (hasExtent) hash ^= extent_.GetHashCode();
          hash ^= base.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Layer other = obj as Layer;
          if (other == null) return false;
          if (hasVersion != other.hasVersion || (hasVersion && !version_.Equals(other.version_))) return false;
          if (hasName != other.hasName || (hasName && !name_.Equals(other.name_))) return false;
          if(features_.Count != other.features_.Count) return false;
          for(int ix=0; ix < features_.Count; ix++)
            if(!features_[ix].Equals(other.features_[ix])) return false;
          if(keys_.Count != other.keys_.Count) return false;
          for(int ix=0; ix < keys_.Count; ix++)
            if(!keys_[ix].Equals(other.keys_[ix])) return false;
          if(values_.Count != other.values_.Count) return false;
          for(int ix=0; ix < values_.Count; ix++)
            if(!values_[ix].Equals(other.values_[ix])) return false;
          if (hasExtent != other.hasExtent || (hasExtent && !extent_.Equals(other.extent_))) return false;
          if (!base.Equals(other)) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("name", hasName, name_, writer);
          PrintField("features", features_, writer);
          PrintField("keys", keys_, writer);
          PrintField("values", values_, writer);
          PrintField("extent", hasExtent, extent_, writer);
          PrintField("version", hasVersion, version_, writer);
          base.PrintTo(writer);
        }
        #endregion
        
        public static Layer ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Layer ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Layer ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Layer ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Layer ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Layer ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Layer ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Layer ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Layer ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Layer ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Layer MakeReadOnly() {
          features_.MakeReadOnly();
          keys_.MakeReadOnly();
          values_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Layer prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilderLite<Layer, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Layer cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Layer result;
          
          private Layer PrepareBuilder() {
            if (resultIsReadOnly) {
              Layer original = result;
              result = new Layer();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Layer MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Layer DefaultInstanceForType {
            get { return global::vector_tile.Tile.Types.Layer.DefaultInstance; }
          }
          
          public override Layer BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Layer) {
              return MergeFrom((Layer) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Layer other) {
            if (other == global::vector_tile.Tile.Types.Layer.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasVersion) {
              Version = other.Version;
            }
            if (other.HasName) {
              Name = other.Name;
            }
            if (other.features_.Count != 0) {
              result.features_.Add(other.features_);
            }
            if (other.keys_.Count != 0) {
              result.keys_.Add(other.keys_);
            }
            if (other.values_.Count != 0) {
              result.values_.Add(other.values_);
            }
            if (other.HasExtent) {
              Extent = other.Extent;
            }
              this.MergeExtensionFields(other);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_layerFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _layerFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasName = input.ReadString(ref result.name_);
                  break;
                }
                case 18: {
                  input.ReadMessageArray(tag, field_name, result.features_, global::vector_tile.Tile.Types.Feature.DefaultInstance, extensionRegistry);
                  break;
                }
                case 26: {
                  input.ReadStringArray(tag, field_name, result.keys_);
                  break;
                }
                case 34: {
                  input.ReadMessageArray(tag, field_name, result.values_, global::vector_tile.Tile.Types.Value.DefaultInstance, extensionRegistry);
                  break;
                }
                case 40: {
                  result.hasExtent = input.ReadUInt32(ref result.extent_);
                  break;
                }
                case 120: {
                  result.hasVersion = input.ReadUInt32(ref result.version_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasVersion {
            get { return result.hasVersion; }
          }
          [global::System.CLSCompliant(false)]
          public uint Version {
            get { return result.Version; }
            set { SetVersion(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetVersion(uint value) {
            PrepareBuilder();
            result.hasVersion = true;
            result.version_ = value;
            return this;
          }
          public Builder ClearVersion() {
            PrepareBuilder();
            result.hasVersion = false;
            result.version_ = 1;
            return this;
          }
          
          public bool HasName {
            get { return result.hasName; }
          }
          public string Name {
            get { return result.Name; }
            set { SetName(value); }
          }
          public Builder SetName(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasName = true;
            result.name_ = value;
            return this;
          }
          public Builder ClearName() {
            PrepareBuilder();
            result.hasName = false;
            result.name_ = "";
            return this;
          }
          
          public pbc::IPopsicleList<global::vector_tile.Tile.Types.Feature> FeaturesList {
            get { return PrepareBuilder().features_; }
          }
          public int FeaturesCount {
            get { return result.FeaturesCount; }
          }
          public global::vector_tile.Tile.Types.Feature GetFeatures(int index) {
            return result.GetFeatures(index);
          }
          public Builder SetFeatures(int index, global::vector_tile.Tile.Types.Feature value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.features_[index] = value;
            return this;
          }
          public Builder SetFeatures(int index, global::vector_tile.Tile.Types.Feature.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.features_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddFeatures(global::vector_tile.Tile.Types.Feature value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.features_.Add(value);
            return this;
          }
          public Builder AddFeatures(global::vector_tile.Tile.Types.Feature.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.features_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeFeatures(scg::IEnumerable<global::vector_tile.Tile.Types.Feature> values) {
            PrepareBuilder();
            result.features_.Add(values);
            return this;
          }
          public Builder ClearFeatures() {
            PrepareBuilder();
            result.features_.Clear();
            return this;
          }
          
          public pbc::IPopsicleList<string> KeysList {
            get { return PrepareBuilder().keys_; }
          }
          public int KeysCount {
            get { return result.KeysCount; }
          }
          public string GetKeys(int index) {
            return result.GetKeys(index);
          }
          public Builder SetKeys(int index, string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.keys_[index] = value;
            return this;
          }
          public Builder AddKeys(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.keys_.Add(value);
            return this;
          }
          public Builder AddRangeKeys(scg::IEnumerable<string> values) {
            PrepareBuilder();
            result.keys_.Add(values);
            return this;
          }
          public Builder ClearKeys() {
            PrepareBuilder();
            result.keys_.Clear();
            return this;
          }
          
          public pbc::IPopsicleList<global::vector_tile.Tile.Types.Value> ValuesList {
            get { return PrepareBuilder().values_; }
          }
          public int ValuesCount {
            get { return result.ValuesCount; }
          }
          public global::vector_tile.Tile.Types.Value GetValues(int index) {
            return result.GetValues(index);
          }
          public Builder SetValues(int index, global::vector_tile.Tile.Types.Value value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.values_[index] = value;
            return this;
          }
          public Builder SetValues(int index, global::vector_tile.Tile.Types.Value.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.values_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddValues(global::vector_tile.Tile.Types.Value value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.values_.Add(value);
            return this;
          }
          public Builder AddValues(global::vector_tile.Tile.Types.Value.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.values_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeValues(scg::IEnumerable<global::vector_tile.Tile.Types.Value> values) {
            PrepareBuilder();
            result.values_.Add(values);
            return this;
          }
          public Builder ClearValues() {
            PrepareBuilder();
            result.values_.Clear();
            return this;
          }
          
          public bool HasExtent {
            get { return result.hasExtent; }
          }
          [global::System.CLSCompliant(false)]
          public uint Extent {
            get { return result.Extent; }
            set { SetExtent(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetExtent(uint value) {
            PrepareBuilder();
            result.hasExtent = true;
            result.extent_ = value;
            return this;
          }
          public Builder ClearExtent() {
            PrepareBuilder();
            result.hasExtent = false;
            result.extent_ = 4096;
            return this;
          }
        }
        static Layer() {
          object.ReferenceEquals(global::vector_tile.VectorTile.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int LayersFieldNumber = 3;
    private pbc::PopsicleList<global::vector_tile.Tile.Types.Layer> layers_ = new pbc::PopsicleList<global::vector_tile.Tile.Types.Layer>();
    public scg::IList<global::vector_tile.Tile.Types.Layer> LayersList {
      get { return layers_; }
    }
    public int LayersCount {
      get { return layers_.Count; }
    }
    public global::vector_tile.Tile.Types.Layer GetLayers(int index) {
      return layers_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::vector_tile.Tile.Types.Layer element in LayersList) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _tileFieldNames;
      pb::ExtendableMessageLite<Tile, Tile.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (layers_.Count > 0) {
        output.WriteMessageArray(3, field_names[0], layers_);
      }
      extensionWriter.WriteUntil(8192, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::vector_tile.Tile.Types.Layer element in LayersList) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      foreach(global::vector_tile.Tile.Types.Layer i in layers_)
        hash ^= i.GetHashCode();
      hash ^= base.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Tile other = obj as Tile;
      if (other == null) return false;
      if(layers_.Count != other.layers_.Count) return false;
      for(int ix=0; ix < layers_.Count; ix++)
        if(!layers_[ix].Equals(other.layers_[ix])) return false;
      if (!base.Equals(other)) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("layers", layers_, writer);
      base.PrintTo(writer);
    }
    #endregion
    
    public static Tile ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Tile ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Tile ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Tile ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Tile ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Tile ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Tile ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Tile ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Tile ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Tile ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Tile MakeReadOnly() {
      layers_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Tile prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::ExtendableBuilderLite<Tile, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Tile cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Tile result;
      
      private Tile PrepareBuilder() {
        if (resultIsReadOnly) {
          Tile original = result;
          result = new Tile();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Tile MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Tile DefaultInstanceForType {
        get { return global::vector_tile.Tile.DefaultInstance; }
      }
      
      public override Tile BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Tile) {
          return MergeFrom((Tile) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Tile other) {
        if (other == global::vector_tile.Tile.DefaultInstance) return this;
        PrepareBuilder();
        if (other.layers_.Count != 0) {
          result.layers_.Add(other.layers_);
        }
          this.MergeExtensionFields(other);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tileFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tileFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.layers_, global::vector_tile.Tile.Types.Layer.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public pbc::IPopsicleList<global::vector_tile.Tile.Types.Layer> LayersList {
        get { return PrepareBuilder().layers_; }
      }
      public int LayersCount {
        get { return result.LayersCount; }
      }
      public global::vector_tile.Tile.Types.Layer GetLayers(int index) {
        return result.GetLayers(index);
      }
      public Builder SetLayers(int index, global::vector_tile.Tile.Types.Layer value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.layers_[index] = value;
        return this;
      }
      public Builder SetLayers(int index, global::vector_tile.Tile.Types.Layer.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.layers_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLayers(global::vector_tile.Tile.Types.Layer value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.layers_.Add(value);
        return this;
      }
      public Builder AddLayers(global::vector_tile.Tile.Types.Layer.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.layers_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLayers(scg::IEnumerable<global::vector_tile.Tile.Types.Layer> values) {
        PrepareBuilder();
        result.layers_.Add(values);
        return this;
      }
      public Builder ClearLayers() {
        PrepareBuilder();
        result.layers_.Clear();
        return this;
      }
    }
    static Tile() {
      object.ReferenceEquals(global::vector_tile.VectorTile.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
